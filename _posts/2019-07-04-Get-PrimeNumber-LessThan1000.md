---
layout: post
title: 1000이하의 소수 구하기
category: Algorithm-Basic
tags: [Algorithm-Basic]
---

# 1000 이하의 모든 소수 구하기
<br/>
<br/>
여담이지만 정의란 것이 참 중요하다는 것을 느꼈다. <br/>
`소수`를 무엇으로 보는가에 따라 알고리즘이 달라지고 비용(cost)이 차이가 난다.<br/> 
<br/>
## 소수 (Prime Number) ?
<pre class="highlight">
<strong style="font-size: 14pt;">소수 'n' = Prime Number 'n'</strong>
<br/>
 수업시간에는 "1과 자기 자신 'n'만을 약수로 가지는 수"라고 배웠던 것 같다.
 하지만 프로그래밍이 이렇게 알아들을 수는 없는 법 그래서 아래와 같은 정의들이 나타난다.
 
 - 정의1) : <strong>"2부터 (n-1)까지의 어떤 정수로도 나누어 떨어지지 않는 수"<strong/>
 - 정의2) : <strong>"2부터 (n-1)까지의 어떤 '소수'로도 나누어 떨어지지 않는 수"<strong/>
 - 정의3) : <strong>"2부터 'n의 제곱근 이하의 모든 소수'로 나누어떨어지지 않는 수"<strong/>
</pre>

### 정의1)
이 경우 n이 소수인지 판단할때,<br/>
 * <u><strong>Tip</strong></u> : (2를 먼저 소수값에 포함시키고 홀수만 반복시키면 좋다!)
n을 2~(n-1)사이 내 <u>홀수값만</u> 반복문을 돌며 나눠봐야하므로 cost가 제일 크다.
<br/>
<br/>
### 정의2)
이 경우 n이 소수인지 판단할때,<br/>
n을 2~(n-1)사이 내 <u>홀수값</u> 중 소수인 값만만 반복문을 돌며 값을 나누므로 1번보다는 const가 작다.
<br/>
<br/>
### 정의3)
이 경우 n이 소수인지 판단할때,<br/>
n을 2~(n제곱근)사이 내 <u>홀수값</u> 중 소수인 값만만 반복문을 돌며 값을 나누므로 const가 제일 작다.<br/>
( n-1이 n제곱근 값보다는 크니까 반복문을 많이 돌며 나눠보게 되므로 )<br/>
그치만 이 방식도 제곱근을 어떻게 구하고 판단할 것인가에 따라 비용이 많이 차이날 것 같다. <br/>
<br/>
#### 정의3으로 소수를 판별할 수 있는 이유?
<pre class="highlight">

 소수는 소수로만 나누어떨어진다고 했다. 그렇다면 나누어 떨어지는 모든 수  = <strong>'약수'</strong>를 보자.
 
 100의 약수는 (1,2,4,5,10,20,25,50,100)이다.
 
 여기서, 소수가 아닌 (1,100)조합을 제외하고,
 (2,50), (4,25), (5,20), (10,10), (20,5), (25,4), (50,2)로 좌표표시시 너비가 100인 사각형을 그린다.
 100의 제곱근 (10,10) 조합을 기준으로 대칭을 이루므로 이후의 값으로 나누어지는지 판단하는 것은 의미가 없다.
 └> ex) 2로 나뉜다면 굳이 50으로 나뉘는지 또 나눠볼 필요가 없다.
 => 그러므로 <strong>n의 제곱근 이하</strong>의 수까지만 나뉘지는지 보면 된다!!
 
 하지만 왜 <strong>n의 제곱근 이하의 모든 소수</strong>만 봐야할까?
 (4,25)를 봐보자
 4는 소수가 아니다. 2로 나뉘기 떄문이다. 그렇다는건 100도 2로 나뉜다는 말이다.
 당연히, 소수가 아닌 수(4)로 나뉘면 그 약수(2)로도 나뉘므로 당연히 소수가 아니다.
 (소수로 나뉘는 수도 소수가 아니지만) 이 경우는 굳이 나누볼 필요가 없다는 것이다!
</pre>
<br/>


<br/>
